--//=========================================================\\--
--||                    MATRIXHUB V3                         ||--
--||        Advanced Targeting and Movement System           ||--
--||           (C++ Style UI | Professional Build)           ||--
--\\=========================================================//--

-- Core Service References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local VirtualUser = game:GetService("VirtualUser")
local Workspace = game:GetService("Workspace")

-- Add Stats service with error handling
local Stats = nil
pcall(function() 
    Stats = game:GetService("Stats")
end)

-- Player References
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- Version Information
local VERSION = "3.0.2"
local BUILD_DATE = "01-03-2025"
local BUILD_ID = "MHB-" .. HttpService:GenerateGUID(false):sub(1, 8)

-- Memory Management
local memory = {
    connections = {},
    drawings = {},
    hooks = {},
    cache = {},
    targets = {},
    config = {}
}

-- Performance Optimization
local math_random = math.random
local math_randomseed = math.randomseed
local math_floor = math.floor
local math_ceil = math.ceil
local math_sin = math.sin
local math_cos = math.cos
local math_tan = math.tan
local math_abs = math.abs
local math_rad = math.rad
local math_deg = math.deg
local math_min = math.min
local math_max = math.max
local math_clamp = math.clamp
local math_huge = math.huge
local table_insert = table.insert
local table_remove = table.remove
local table_find = table.find
local table_clear = table.clear
local string_format = string.format
local string_sub = string.sub
local string_match = string.match
local string_gsub = string.gsub
local string_lower = string.lower
local string_upper = string.upper
local string_len = string.len
local os_time = os.time
local os_date = os.date
local os_clock = os.clock
local Vector2_new = Vector2.new
local Vector3_new = Vector3.new
local CFrame_new = CFrame.new
local CFrame_Angles = CFrame.Angles
local Color3_new = Color3.new
local Color3_fromRGB = Color3.fromRGB
local Color3_fromHSV = Color3.fromHSV
local UDim2_new = UDim2.new
local UDim_new = UDim.new
local Instance_new = Instance.new
local Ray_new = Ray.new
local Drawing_new = Drawing.new
local TweenInfo_new = TweenInfo.new
local Enum_KeyCode = Enum.KeyCode
local Enum_UserInputType = Enum.UserInputType
local Enum_TextXAlignment = Enum.TextXAlignment
local Enum_ZIndexBehavior = Enum.ZIndexBehavior
local Enum_Font = Enum.Font

-- Security System
local securityToken = HttpService:GenerateGUID(false)
local encryptionKey = string.sub(HttpService:GenerateGUID(false), 1, 16)

-- Filesystem check and compatibility
local fileSystemAvailable = true
local function checkFileSystem()
    local success = pcall(function()
        if isfolder and makefolder and writefile and readfile and listfiles and delfile then
            return true
        else
            return false
        end
    end)
    return success
end
fileSystemAvailable = checkFileSystem()

-- Drawing function compatibility check
local drawingAvailable = true
local function checkDrawing()
    local success = pcall(function()
        local testDrawing = Drawing.new("Circle")
        testDrawing:Remove()
        return true
    end)
    return success
end
drawingAvailable = checkDrawing()

-- Error Handling and Secure Function Calls
local function createSecureWrapper(name)
    return function(func)
        return function(...)
            local args = {...}
            local success, result = pcall(function()
                return func(unpack(args))
            end)
            
            if not success then
                local errorId = HttpService:GenerateGUID(false):sub(1, 8)
                warn("[MatrixHub][" .. name .. "][Error:" .. errorId .. "] " .. tostring(result))
                
                -- Log error for diagnostics
                memory.cache.errorLogs = memory.cache.errorLogs or {}
                table_insert(memory.cache.errorLogs, {
                    id = errorId,
                    timestamp = os_time(),
                    component = name,
                    message = tostring(result),
                    stack = debug.traceback()
                })
            end
            
            return success and result or nil
        end
    end
end

local secureUI = createSecureWrapper("UI")
local secureAim = createSecureWrapper("Aim")
local secureESP = createSecureWrapper("ESP")
local secureMovement = createSecureWrapper("Movement")
local secureMisc = createSecureWrapper("Misc")
local secureConfig = createSecureWrapper("Config")

--//================ UTILITY FUNCTIONS ================\\--
local Utility = {}

-- String Encryption/Decryption for Config
Utility.Encrypt = function(str)
    if not str then return "" end
    local result = ""
    for i = 1, #str do
        local char = string.byte(str, i)
        local keyChar = string.byte(encryptionKey, (i % #encryptionKey) + 1)
        result = result .. string.char(bit32.bxor(char, keyChar))
    end
    return result
end

Utility.Decrypt = function(str)
    return Utility.Encrypt(str) -- XOR encryption is symmetrical
end

-- Vector Calculations
Utility.GetDistance = function(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

Utility.GetDirection = function(origin, target)
    return (target - origin).Unit
end

-- Validation Functions
Utility.IsAlive = function(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

Utility.IsVisible = function(character, part)
    if not character or not part then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = Workspace:Raycast(origin, direction * 9999, rayParams)
    
    return result and result.Instance and (result.Instance:IsDescendantOf(character) or result.Instance == part)
end

Utility.IsTeammate = function(player)
    if not player or player == LocalPlayer then return false end
    
    -- Universal Team Check
    if player.Team and LocalPlayer.Team then
        return player.Team == LocalPlayer.Team
    end
    
    -- FFA Game Detection (based on character colors)
    if player.Character and LocalPlayer.Character then
        local playerTorso = player.Character:FindFirstChild("HumanoidRootPart")
        local localTorso = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if playerTorso and localTorso and playerTorso:FindFirstChild("BrickColor") and localTorso:FindFirstChild("BrickColor") then
            return playerTorso.BrickColor == localTorso.BrickColor
        end
    end
    
    return false
end

-- Game Analysis
Utility.AnalyzeGame = function()
    local gameData = {
        weaponSystem = "Unknown",
        movementType = "Standard",
        hasFallDamage = false,
        teamBased = true,
        supportsSilentAim = true
    }
    
    -- Check for common weapon systems
    if ReplicatedStorage:FindFirstChild("Weapons") then
        gameData.weaponSystem = "Standard"
    elseif ReplicatedStorage:FindFirstChild("Framework") then
        gameData.weaponSystem = "Framework"
    elseif ReplicatedStorage:FindFirstChild("Modules") and ReplicatedStorage.Modules:FindFirstChild("Gun") then
        gameData.weaponSystem = "Modular"
    end
    
    -- Check movement type
    if Workspace:FindFirstChild("Gravity") then
        if Workspace.Gravity < 196.2 then
            gameData.movementType = "LowGravity"
        end
    end
    
    -- Check for anti-cheat systems (simplified detection)
    memory.cache.antiCheatDetected = false
    
    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
        if string.match(string.lower(v.Name), "anti") and string.match(string.lower(v.Name), "cheat") or
           string.match(string.lower(v.Name), "security") or string.match(string.lower(v.Name), "report") then
            memory.cache.antiCheatDetected = true
            break
        end
    end
    
    return gameData
end

-- Player Analysis
Utility.AnalyzePlayers = function()
    local result = {
        averageHealth = 0,
        commonParts = {},
        playerCount = 0
    }
    
    local partCounts = {}
    local totalHealth = 0
    local playerCount = 0
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            playerCount = playerCount + 1
            
            -- Analyze health
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                totalHealth = totalHealth + humanoid.Health
            end
            
            -- Analyze character structure
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    partCounts[part.Name] = (partCounts[part.Name] or 0) + 1
                end
            end
        end
    end
    
    -- Calculate average health
    if playerCount > 0 then
        result.averageHealth = totalHealth / playerCount
        result.playerCount = playerCount
        
        -- Find common parts
        for part, count in pairs(partCounts) do
            if count >= playerCount * 0.8 then -- If 80% of players have this part
                table_insert(result.commonParts, part)
            end
        end
    end
    
    return result
end

-- Performance Monitoring
Utility.StartPerformanceMonitoring = function()
    memory.cache.performanceStats = {
        fps = 0,
        ping = 0,
        memoryUsage = 0,
        startTime = os_clock()
    }
    
    local frameCount = 0
    local lastUpdate = os_clock()
    
    memory.connections.performanceMonitor = RunService.RenderStepped:Connect(function()
        frameCount = frameCount + 1
        
        local currentTime = os_clock()
        local elapsed = currentTime - lastUpdate
        
        if elapsed >= 1 then
            memory.cache.performanceStats.fps = math_floor(frameCount / elapsed)
            memory.cache.performanceStats.ping = LocalPlayer:GetNetworkPing() * 1000
            
            -- Fixed Stats service usage with error handling
            if Stats then
                pcall(function()
                    memory.cache.performanceStats.memoryUsage = math_floor(Stats:GetTotalMemoryUsageInMB())
                end)
            else
                memory.cache.performanceStats.memoryUsage = 0
            end
            
            frameCount = 0
            lastUpdate = currentTime
        end
    end)
end

--//================ CORE SETTINGS SYSTEM ================\\--
local Settings = {
    -- Core System Settings
    UI = {
        Enabled = true,
        Theme = {
            Primary = Color3_fromRGB(24, 24, 36),     -- Dark Background
            Secondary = Color3_fromRGB(12, 12, 24),   -- Darker Background
            Accent = Color3_fromRGB(0, 120, 215),     -- Blue Accent
            Text = Color3_fromRGB(230, 230, 230),     -- Light Text
            Highlight = Color3_fromRGB(0, 155, 240),  -- Highlight Blue
            Error = Color3_fromRGB(225, 70, 70),      -- Error Red
            Success = Color3_fromRGB(70, 225, 70),    -- Success Green
            Warning = Color3_fromRGB(225, 225, 70)    -- Warning Yellow
        },
        Font = Enum_Font.Code,
        FontSize = {
            Title = 18,
            Subtitle = 16,
            Regular = 14,
            Small = 12
        },
        Animation = {
            Enabled = true,
            Speed = 0.3
        },
        Draggable = true,
        Minimizable = true,
        Transparency = 0.95,
        ShowPerformance = true,
        ShowTooltips = true,
        ShowKeybinds = true,
        Scale = 1.0
    },
    
    -- Aimbot Settings
    Aimbot = {
        Enabled = false,
        ToggleKey = Enum_KeyCode.Q,
        HoldKey = Enum_KeyCode.E,
        HoldMode = true,
        TeamCheck = true,
        VisibilityCheck = false,
        TargetPart = "Head",
        FallbackParts = {"HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"},
        FOV = 250,
        ShowFOV = true,
        FOVColor = Color3_fromRGB(255, 0, 0),
        FOVTransparency = 0.5,
        FOVSides = 60,
        Smoothing = 2,
        SmartPrediction = true,
        PredictionAmount = 0.165,
        WallPenetration = false,
        SnapLines = false,
        SnapLineColor = Color3_fromRGB(255, 0, 0),
        SnapLineTransparency = 0.5,
        SnapLineThickness = 1,
        MaxDistance = 1000,
        TargetPriority = "FOV", -- FOV, Distance, Health
        RecoilControl = 0.5,     -- 0 to 1, 0 being no control, 1 being full control
        AutoShoot = false,
        AutoShootDelay = 0.1,
        AutoScope = false,
        SmartTargeting = true,
        HitboxExpansion = 0,
        StickyAim = false,
        StickyAimStrength = 0.5
    },
    
    -- Silent Aim Settings
    SilentAim = {
        Enabled = false,
        ToggleKey = Enum_KeyCode.LeftAlt,
        TeamCheck = true,
        VisibilityCheck = false,
        TargetPart = "Head",
        FallbackParts = {"HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"},
        FOV = 300,
        ShowFOV = true,
        FOVColor = Color3_fromRGB(0, 255, 0),
        FOVTransparency = 0.5,
        FOVSides = 60,
        HitChance = 100,
        HitboxExpanderEnabled = false,
        HitboxExpansionAmount = 2,
        HeadshotChance = 70,
        AutoWallBang = false,
        DoubleTapEnabled = false,
        MaxDistance = 2000,
        DynamicHitChance = true, -- Adjust hit chance based on distance
        TargetPriority = "FOV",
        PredictionAmount = 0.165,
        SmartPrediction = true,
        BlatantMode = false, -- Bypasses hit chance and always hits target
        Advertise = false, -- Periodically shows hit marker to other players (subtle advertising)
        ShowDebugInfo = false
    },
    
    -- Trigger Bot Settings
    TriggerBot = {
        Enabled = false,
        ToggleKey = Enum_KeyCode.T,
        HoldKey = Enum_KeyCode.X,
        HoldMode = false,
        TeamCheck = true,
        VisibilityCheck = true,
        Delay = 0,
        DelayVariance = 10, -- Random variance in ms
        HitChance = 100,
        MaxDistance = 1000,
        FireMethod = "Click", -- Click, Virtual, Input
        TargetPart = "Head",
        FOV = 100, -- Only trigger within this FOV
        ShowFOV = false,
        FOVColor = Color3_fromRGB(255, 255, 0),
        IgnoreTransparentParts = true,
        RandomHitboxOffset = false,
        HitboxOffsetRange = Vector3_new(0.1, 0.1, 0.1),
        OnlyTargetPlayers = true,
        ReactionTimeSimulation = true,
        MinReactionTime = 100, -- ms
        MaxReactionTime = 250  -- ms
    },
    
    -- Character/Movement Settings
    Character = {
        SpeedEnabled = false,
        SpeedToggleKey = Enum_KeyCode.LeftShift,
        SpeedAmount = 2,
        SpeedMethod = "CFrame", -- CFrame, Walkspeed, Velocity, Physics
        SpeedMode = "Constant", -- Constant, Boost, Toggle
        JumpPowerEnabled = false,
        JumpPowerToggleKey = Enum_KeyCode.Space,
        JumpPowerAmount = 75,
        NoClipEnabled = false,
        NoClipToggleKey = Enum_KeyCode.Z,
        InfiniteJumpEnabled = false,
        InfiniteJumpToggleKey = Enum_KeyCode.Space,
        FlyEnabled = false,
        FlyToggleKey = Enum_KeyCode.F,
        FlySpeed = 2,
        Bypasses = {
            AntiCheatA = false,
            AntiCheatB = false,
            AntiCheatC = false
        },
        CameraMethod = {
            ThirdPerson = false,
            ThirdPersonKey = Enum_KeyCode.P,
            ThirdPersonDistance = 10,
            FreeCam = false,
            FreeCamKey = Enum_KeyCode.L,
            FreeCamSpeed = 2
        },
        BunnyHopEnabled = false,
        BunnyHopKey = Enum_KeyCode.Space,
        BunnyHopHeight = 25,
        BunnyHopSpeed = 1.5,
        AntiStumble = false,
        AntiRagdoll = false,
        AntiKnockback = false,
        NoFallDamage = false,
        AutoSprint = false,
        WalkSpeedBoost = 0 -- Additional WalkSpeed boost
    },
    
    -- ESP Settings
    ESP = {
        Enabled = false,
        ToggleKey = Enum_KeyCode.RightAlt,
        TeamCheck = false,
        TeamColor = true,
        Boxes = true,
        BoxesOutline = true,
        BoxesColor = Color3_fromRGB(255, 255, 255),
        BoxesTransparency = 0.7,
        BoxesOutlineColor = Color3_fromRGB(0, 0, 0),
        Names = true,
        NamesOutline = true,
        NamesColor = Color3_fromRGB(255, 255, 255),
        NamesTransparency = 0.7,
        NamesOutlineColor = Color3_fromRGB(0, 0, 0),
        NamesFont = "Monospace", -- Monospace, System, UI
        NamesSize = 14,
        Distance = true,
        DistanceOutline = true,
        DistanceColor = Color3_fromRGB(255, 255, 255),
        DistanceTransparency = 0.7,
        DistanceOutlineColor = Color3_fromRGB(0, 0, 0),
        DistanceFont = "Monospace",
        DistanceSize = 13,
        Tracers = false,
        TracersOrigin = "Bottom", -- Bottom, Mouse, Top
        TracersColor = Color3_fromRGB(255, 255, 255),
        TracersTransparency = 0.7,
        TracersThickness = 1,
        Health = true,
        HealthOutline = true,
        HealthColor = Color3_fromRGB(0, 255, 0),
        HealthTransparency = 0.7,
        HealthOutlineColor = Color3_fromRGB(0, 0, 0),
        HealthBarType = "Side", -- Side, Bottom, Text
        Weapon = false,
        WeaponOutline = true,
        WeaponColor = Color3_fromRGB(255, 255, 255),
        WeaponTransparency = 0.7,
        WeaponOutlineColor = Color3_fromRGB(0, 0, 0),
        Skeletons = false,
        SkeletonsColor = Color3_fromRGB(255, 255, 255),
        SkeletonsTransparency = 0.7,
        SkeletonsThickness = 1,
        Chams = false,
        ChamsColor = Color3_fromRGB(255, 0, 0),
        ChamsTransparency = 0.5,
        ChamsOutlineColor = Color3_fromRGB(0, 0, 0),
        ChamsOutlineTransparency = 0.5,
        ChamsRainbowEffect = false,
        RainbowSpeed = 1,
        ShowLookDirection = false,
        LookDirectionColor = Color3_fromRGB(255, 255, 0),
        MaxDistance = 2000,
        RefreshRate = 10, -- ms
        PlayerInfo = true, -- Shows health, armor, etc.
        HideLocalPlayer = true
    },
    
    -- Misc Settings
    Misc = {
        NoRecoilEnabled = false,
        NoRecoilAmount = 1, -- 0 to 1
        NoSpreadEnabled = false,
        NoSpreadAmount = 1, -- 0 to 1
        AutoReloadEnabled = false,
        AutoFireEnabled = false,
        RapidFireEnabled = false,
        RapidFireRate = 0.05,
        WallBangEnabled = false,
        AutoHealEnabled = false,
        HitMarkerEnabled = false,
        HitMarkerColor = Color3_fromRGB(255, 0, 0),
        HitMarkerDuration = 0.3,
        HitMarkerSound = true,
        HitMarkerSoundID = "rbxassetid://160432334",
        KillSoundEnabled = false,
        KillSoundID = "rbxassetid://4485506334",
        FOVChangerEnabled = false,
        FOVValue = 80,
        CrosshairEnabled = false,
        CrosshairSize = 10,
        CrosshairThickness = 1,
        CrosshairColor = Color3_fromRGB(0, 255, 0),
        CrosshairTransparency = 0.5,
        AntiAFKEnabled = true,
        ChatSpammerEnabled = false,
        ChatSpammerDelay = 3,
        ChatSpammerMessages = {"MatrixHub V3 on top!", "Get good, get MatrixHub!", "Nice aim bro, try Matrix!"},
        KillAuraEnabled = false,
        KillAuraRange = 10,
        KillAuraDelay = 0.5,
        AutoPickupEnabled = false,
        AutoPickupRange = 10,
        ServerLaggerEnabled = false,
        ServerLaggerIntensity = 5,
        BunnyHopEnabled = false,
        AutoJoinBestTeamEnabled = false,
        AutoQueueEnabled = false,
        AutoQueueDelay = 3,
        NametagChangerEnabled = false,
        CustomNametag = "MatrixHub User",
        SkinChangerEnabled = false,
        CustomSkinID = "0"
    },
    
    -- Config System
    Config = {
        AutoSave = true,
        SaveInterval = 300, -- 5 minutes
        NotifyOnSave = true,
        DefaultConfig = "Default",
        ConfigVersion = 1
    }
}

-- Config System
local ConfigSystem = {}

ConfigSystem.SaveConfig = secureConfig(function(configName)
    if not fileSystemAvailable then
        warn("[MatrixHub] Config saving is not available - filesystem functions not supported")
        return false
    end
    
    configName = configName or Settings.Config.DefaultConfig
    
    -- Create config folder if it doesn't exist
    pcall(function()
        if not isfolder("MatrixHub") then
            makefolder("MatrixHub")
        end
        
        if not isfolder("MatrixHub/Configs") then
            makefolder("MatrixHub/Configs")
        end
    end)
    
    -- Create config data
    local configData = {
        version = Settings.Config.ConfigVersion,
        timestamp = os_time(),
        gameId = game.PlaceId,
        settings = Settings
    }
    
    -- Encrypt and save config
    local success, result = pcall(function()
        local jsonData = HttpService:JSONEncode(configData)
        local encryptedData = Utility.Encrypt(jsonData)
        writefile("MatrixHub/Configs/" .. configName .. ".mhconf", encryptedData)
        return true
    end)
    
    return success
end)

ConfigSystem.LoadConfig = secureConfig(function(configName)
    if not fileSystemAvailable then
        warn("[MatrixHub] Config loading is not available - filesystem functions not supported")
        return false
    end
    
    configName = configName or Settings.Config.DefaultConfig
    local configPath = "MatrixHub/Configs/" .. configName .. ".mhconf"
    
    if not isfile(configPath) then
        return false, "Config file not found"
    end
    
    local success, result = pcall(function()
        local encryptedData = readfile(configPath)
        local jsonData = Utility.Decrypt(encryptedData)
        local configData = HttpService:JSONDecode(jsonData)
        
        -- Version check
        if configData.version ~= Settings.Config.ConfigVersion then
            return false, "Config version mismatch"
        end
        
        -- Update settings
        Settings = configData.settings
        return true
    end)
    
    return success, result
end)

ConfigSystem.GetConfigList = secureConfig(function()
    if not fileSystemAvailable then
        return {}
    end
    
    if not isfolder("MatrixHub/Configs") then
        return {}
    end
    
    local files = {}
    pcall(function()
        files = listfiles("MatrixHub/Configs")
    end)
    
    local configs = {}
    
    for _, file in ipairs(files) do
        local fileName = string.match(file, "([^/\\]+)%.mhconf$")
        if fileName then
            table_insert(configs, fileName)
        end
    end
    
    return configs
end)

ConfigSystem.DeleteConfig = secureConfig(function(configName)
    if not fileSystemAvailable then
        return false
    end
    
    local configPath = "MatrixHub/Configs/" .. configName .. ".mhconf"
    
    if not isfile(configPath) then
        return false, "Config file not found"
    end
    
    local success, result = pcall(function()
        delfile(configPath)
        return true
    end)
    
    return success, result
end)

--//================ UI SYSTEM ================\\--
local UI = {}

UI.CreateNew = secureUI(function()
    local MatrixUI = {}
    
    -- ScreenGui Creation with Nezur compatibility
    local MatrixHub = Instance_new("ScreenGui")
    MatrixHub.Name = "MatrixHubV3_" .. HttpService:GenerateGUID(false):sub(1, 8)  -- Randomize name for security
    MatrixHub.ResetOnSpawn = false
    MatrixHub.DisplayOrder = 9999
    MatrixHub.ZIndexBehavior = Enum_ZIndexBehavior.Sibling
    
    -- Safely set parent with multiple fallback options for Nezur compatibility
    local success = false
    
    -- Try methods in order of preference
    local parentMethods = {
        function()
            -- Method 1: Standard CoreGui approach
            if syn and syn.protect_gui then
                syn.protect_gui(MatrixHub)
                MatrixHub.Parent = game:GetService("CoreGui")
                return true
            end
            return false
        end,
        
        function()
            -- Method 2: Direct CoreGui parent
            MatrixHub.Parent = game:GetService("CoreGui")
            return true
        end,
        
        function() 
            -- Method 3: gethui() method
            if gethui then
                MatrixHub.Parent = gethui()
                return true
            end
            return false
        end,
        
        function()
            -- Method 4: PlayerGui (last resort)
            MatrixHub.Parent = LocalPlayer:WaitForChild("PlayerGui")
            return true
        end
    }
    
    -- Try each method until one succeeds
    for _, method in ipairs(parentMethods) do
        success = pcall(method)
        if success then
            break
        end
    end
    
    if not success then
        warn("[MatrixHub] Failed to create UI - could not set ScreenGui parent")
        return nil
    end
    
    -- Main Components
    local MainFrame = Instance_new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2_new(0, 650, 0, 450)
    MainFrame.Position = UDim2_new(0.5, -325, 0.5, -225)
    MainFrame.BackgroundColor3 = Settings.UI.Theme.Primary
    MainFrame.BorderSizePixel = 0
    MainFrame.ClipsDescendants = true
    MainFrame.Active = true
    MainFrame.Parent = MatrixHub
    
    -- Make UI draggable without .Draggable property for better compatibility
    local dragging = false
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2_new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset +
